'''
11. 자신을 제외한 배열의 곱
배열을 입력받아 output[i]가 자신을 제외한 나머지 모든 요소의 곱셈 결과가 되도록 출력하라.
주의) 나눗셈을 하지 말고 O(n)에 풀이하라.

입력 : [1, 2, 3, 4]
출력 : [24, 12, 8, 6]

Solution 1. 왼쪽 곱셈 결과에 오른쪽 값을 차례대로 곱셈
나눗셈을 하면 안된다는 조건이 있기 때문에, 전체 원소를 곱한 후, 해당 위치의 원소를 나누어 주는 방식은 불가능하다.
따라서, 원소 위치에서, (왼쪽 모든 원소의 곱셈 결과) X (오른쪽 모든 원소의 곱셈 결과)로 구할 수 있다.

< 상세 설명 >
(책 193쪽 그림 7-11 참고)

1. 왼쪽에서 오른쪽으로 원소를 차례로 곱해가며 값들을 저장한다. 이때, 자신을 제외하고 곱해야 하기 때문에, 1부터 시작한다.
    [1, (1 X nums[0]), (nums[0] X nums[1]), (nums[0] X nums[1] X nums[2])] = [1, (1 X 1), (1 X 2), (1 X 2 X 3)] = [1, 1, 2, 6]

2. 이번에는 오른쪽에서부터 왼쪽으로 가면서 원소를 차례로 곱해가며 값들을 저장한다. 마찬가지로, 1부터 시작한다.
    [(nums[1] X nums[2] X nums[3]), (nums[2] X nums[3]), (nums[3] X 1), 1] = [(2 X 3 X 4), (3 X 4), (4 X 1), 1] = [24, 12, 4, 1]

3. 1과 2의 과정에서 얻은 배열을 원소위치끼리(element-wise) 곱한 것이 정답이다.

참고) 풀이에서는 2의 과정에서 배열을 따로 만들지 않고, 바로 out에 곱하였음
'''

import time


def product_except_self(nums):
    out = [] # 최종 결과

    p = 1 # 자신을 제외하고 곱하기 위해서 두는 값 1
    # 상세설명 - 1 : 왼쪽에서 오른쪽으로 원소를 차례로 곱하기
    for i in range(len(nums)):
        out.append(p)
        p = p * nums[i]

    p = 1 # 자신을 제외하고 곱하기 위해서 두는 값 1
    # 상세설명 - 2 : 오른쪽에서 왼쪽으로 원소를 차례로 곱하기
    for i in range(len(nums) - 1, -1, -1):
        # 상세설명 - 3 : 2의 과정에서 나오는 원소(p)를 따로 저장하지 않고, 1의 과정에서 나온 원소(out[i])에 바로 곱해서 저장함
        out[i] = out[i] * p
        p = p * nums[i]
    
    return out


nums = [1, 2, 3, 4]

start_time = time.time() # 시작 시간 측정
result = product_except_self(nums) # 결과 출력
elapsed_time = time.time() - start_time # 소요된 시간 = 현재시간 - 시작 시간

print(result)
print(f"Elapsed time : {elapsed_time} [sec]") # 소요 시간 출력
